#ifndef EC_H
#define EC_H
	#include "ellipticCurve.h"
#endif

class Key
{
public:	
	ecPoint Q;
	Integer d;//Q=dP
};
class publicKey
{
public:
	ellipticCurveFq* E_Fq_ptr;
	ecPoint* basePoint_ptr;
	Integer n; //order of basePoint
	ecPoint* Q_ptr; //Q=d*P, where d is private
};
class SignatureECDSA
{
public:
	Integer r,s;
};
class SignatureELGAMAL
{
public:	
	Integer s;
	ecPoint R;
};
/*Input: R is x-coordinate of point in E(Fq) represented by E_Fq and mod = Order(basepoint) 
Output: Computes result=f(R), 0<=result<mod
Used in Signature Verifcation and Generation algorithms of ECDSA and ELGAMAL*/
void convertElementToInt(Integer& result,ExtensionField::Element& R, Integer& mod, ellipticCurveFq& E_Fq);

/*Input: message and n
Output: returns H(message,n)
Hash function used in Signature Generation and Verification of ECDSA*/
Integer H(Integer& message,Integer& n);

/*Input: basepoint P, E(Fq) represented by E_Fq, n=Order(P)
Output: Secret Key K {Q,d} where Q=d*P */
void KeyPairGeneration(Key& K, ecPoint& P,ellipticCurveFq& E_Fq,Integer& n);

/* Input: Q,E_Fq, n=Order(basepoint)
Output: return true if Q belongs to <P>*/
bool publicKeyValidation(ecPoint& Q,ellipticCurveFq& E_Fq,Integer& n);

/*ECDSA Signature Generation
Input: Secret Key K, message m to be signed, basepoint P in E(Fq) represented by E_Fq, n=order(P) 
Output: Signature S for the message*/
void SignatureGeneration(SignatureECDSA& S, Key& K,Integer& message,ecPoint& P,ellipticCurveFq& E_Fq,Integer& n);

/*ECDSA Signature Verification
Input: Signature S for the message m, Secret Key K, basepoint P in E(Fq) represented by E_Fq, n=order(P), Q=d*P where d is private key 
Output: returns true if message is signed*/
bool SignatureVerification(SignatureECDSA& S,Integer& message,ecPoint& P,ecPoint& Q,ellipticCurveFq& E_Fq,Integer& n);

/*ELGAMAL Signature Generation
Input: Secret Key K, message m to be signed, basepoint P in E(Fq) represented by E_Fq, n=order(P) 
Output: Signature S for the message*/
void SignatureGeneration(SignatureELGAMAL& S, Key& K,Integer& message,ecPoint& P,ellipticCurveFq& E_Fq,Integer& n);

/*ELGAMAL Signature Verification
Input: Signature S for the message m, Secret Key K, basepoint P in E(Fq) represented by E_Fq, n=order(P), Q=d*P where d is private key 
Output: returns true if message is signed*/
bool SignatureVerification(SignatureELGAMAL& S,Integer& message,ecPoint& P,ecPoint& Q,ellipticCurveFq& E_Fq,Integer& n);

/*prints Signature of a message m(an Ineger) generated by ECDSA*/
void showSignature(SignatureECDSA& S);

/*prints Signature of a message m(an Ineger) generated by ELGAMAL*/
void showSignature(SignatureELGAMAL& S,ellipticCurveFq& E_Fq);

/*To input ELGAMAL Signature S as told by the signee of message*/
void inputSignature(SignatureELGAMAL& S,ellipticCurveFq& E_Fq);

/*To input ECDSA Signature S as told by the signee of message*/
void inputSignature(SignatureECDSA& S);

/*Input: basepoint P in E(Fq) represented by E_Fq, n=order(P)
Output: Ka- public Key with Alice, Kb- public Key with Bob
		a and b: secret integer by Alice and Bob respectively*/
void DiffieHellmanKeyExchange(Integer& a, Integer& b, ecPoint& Ka,ecPoint& Kb,ecPoint& P,ellipticCurveFq& E_Fq,Integer& n);

/*Input: message m and E(Fq)
Output: Point representation of m as M âˆˆ E(Fq) 
This function is not yet defined*/
void integerToPoint(ecPoint& M,Integer& m, ellipticCurveFq& E_Fq);

/*Input: message represented as a Point in E(Fq), basepoint P in E(Fq) represented by E_Fq, n=order(P)
Output: Encrypted message {M1,M2} */
void EncryptionELGAMAL(ecPoint& M1, ecPoint& M2, ecPoint& P,ecPoint& Q,ellipticCurveFq& E_Fq,Integer& n, ecPoint& message);

/*Input: Encrypted message {M1,M2}, basepoint P in E(Fq) represented by E_Fq, n=order(P)
Output: message represented as a Point in E(Fq)*/
void DecryptionELGAMAL(ecPoint& message, Integer& d, ecPoint& P,ecPoint& Q,ellipticCurveFq& E_Fq,Integer& n, ecPoint& M1, ecPoint& M2);
